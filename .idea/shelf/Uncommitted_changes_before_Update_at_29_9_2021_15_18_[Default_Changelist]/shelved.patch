Index: src/Dev/Lexico/AnalizadorLexico.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Dev.Lexico;\r\n\r\nimport Dev.RegistroTS;\r\nimport Dev.Lexico.AccionesSemanticas.*;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.FileReader;\r\nimport java.util.ArrayList;\r\n\r\npublic class AnalizadorLexico {\r\n\r\n    public static Map<String, Integer> numeroToken = new HashMap<>();\r\n\r\n    private static AnalizadorLexico instance;\r\n\r\n    public static AnalizadorLexico Instance() {\r\n        if (instance == null)\r\n            instance = new AnalizadorLexico();\r\n        return instance;\r\n    }\r\n\r\n    private AnalizadorLexico() {\r\n        loadValues();\r\n        numeroToken.put(\"Identificador\", 300); // el numero de token que corresponde a un ID es 300\r\n    }\r\n\r\n    private static final int estadoFinal = 16;\r\n\r\n    //region Matrices\r\n    private static final int[][] matrizDeTransicionEstados = {\r\n        {1,1,1,2,estadoFinal,estadoFinal,estadoFinal,0,0,0,6,15,3,9,10,11,12,13,14,estadoFinal},\r\n        {1,estadoFinal,1,1,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {-1,-1,-1,2,estadoFinal,-1,-1,estadoFinal,estadoFinal,-1,-1,-1,3,-1,-1,-1,-1,-1,-1,estadoFinal},\r\n        {-1,4,-1,3,estadoFinal,-1,-1,estadoFinal,estadoFinal,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,estadoFinal},\r\n        {-1,-1,-1,4,estadoFinal,-1,5,estadoFinal,estadoFinal,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,estadoFinal},\r\n        {-1,-1,-1,5,estadoFinal,-1,-1,estadoFinal,estadoFinal,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,estadoFinal},\r\n        {estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,7,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {7,7,7,7,7,7,7,7,7,7,8,7,7,7,7,7,7,7,7,-1},\r\n        {7,7,7,7,7,7,7,7,7,7,0,7,7,7,7,7,7,7,7,-1},\r\n        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,estadoFinal,-1,-1,-1},\r\n        {estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,estadoFinal,-1,-1,-1},\r\n        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,estadoFinal,-1,-1},\r\n        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,estadoFinal,-1},\r\n        {15,15,15,15,15,15,15,15,-1,15,15,estadoFinal,15,15,15,15,15,15,15,-1}\r\n    };\r\n    \r\n    static IAccionSemantica AS1 = new AS1();\r\n    static IAccionSemantica AS2 = new AS2();\r\n    static IAccionSemantica AS3 = new AS3();\r\n    static IAccionSemantica AS4 = new AS4();\r\n    static IAccionSemantica AS5 = new AS5();\r\n    static IAccionSemantica AS6 = new AS6();\r\n    static IAccionSemantica AS7 = new AS7();\r\n    \r\n    private static final IAccionSemantica[][] matrizDeTransicionAS = {\r\n        {AS2, AS2, AS2, AS2, AS1, AS1, AS1, null, null, null, null, AS2, AS2, null, null, null, null, null, null, null}, //0\r\n        {AS3, AS3, AS3, AS3, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4}, //1\r\n        {null, null, null, AS3, AS5, null, null, AS5, AS5, null, null, null, AS3, null, null, null, null, null, null, null}, //2\r\n        {null, AS3, null, AS3, AS5, null, null, AS5, AS5, null, null, null, null, null, null, null, null, null, null, null},//3\r\n        {null, null, null, AS3, AS5, null, AS3, AS5, AS5, null, null, null, null, null, null, null, null, null, null, null},//4\r\n        {null, null, null, AS3, AS5, null, null, AS5, AS5, null, null, null, null, null, null, null, null, null, null, null},//5\r\n        {AS6, AS6, AS6, AS6, AS6, AS6, AS6, AS6, AS6, AS6, null, AS6, AS6, AS6, AS6, AS6, AS6, AS6, AS6, AS6},//6\r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},//7\r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},//8\r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, AS1, null, null, null},//9\r\n        {AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1}, //10\r\n        {AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1}, //11 \r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, AS1, null, null, null},//12\r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, AS1, null, null},//13\r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, AS1, null},//14\r\n        {AS3, AS3, AS3, AS3, AS3, AS3, AS3, AS3, null, AS3, AS3, AS7, AS3, AS3, AS3, AS3, AS3, AS3, AS3, null} //15\r\n\r\n        \r\n/*\r\n           L    \"E\" \"_\"  d  \";\" (),* +- \" \" \\n  tab  /   %  \".\" \":\"  >   <   =   &   |   $\r\n0         AS2\tAS2\tAS2\tAS2\tAS1\tAS1\tAS1\t\t\t\t\tAS2\tAS2\t\t\t\t\t\t\t\r\n1         AS3\tAS3\tAS3\tAS3\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\r\n2                       AS3\tAS5\t\t\tAS5\tAS5\t\t\t\tAS3\t\t\t\t\t\t\t\r\n3               AS3\t    AS3\tAS5\t\t\tAS5\tAS5\t\t\t\t\t\t\t\t\t\t\t\r\n4                       AS3\tAS5\t\tAS3\tAS5\tAS5\t\t\t\t\t\t\t\t\t\t\t\r\n5                       AS3\tAS5\t\t\tAS5\tAS5\t\t\t\t\t\t\t\t\t\t\t\r\n6         AS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\t\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\r\n7                                                                                     \r\n8                                                                                     \r\n9                                                                           AS1\t\t\t\r\n10        AS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\r\n11        AS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\r\n12                                                                          AS1\t\t\t\r\n13                                                                              AS1\t\t\r\n14                                                                                  AS1\t\r\n15        AS3\tAS3\tAS3\tAS3\tAS3\tAS3\tAS3\tAS3\t\tAS3\tAS3\tAS7\tAS3\tAS3\tAS3\tAS3\tAS3\tAS3\tAS3\t\r\n*/\r\n    };\r\n\r\n    //endregion\r\n\r\n    private static List<Character> codigoFuente = new ArrayList<>();\r\n\r\n    private static int indiceUltimoLeido = 0;\r\n\r\n    public static String lexema;\r\n\r\n    //region FileRead\r\n\r\n    final static String FILE_PATH = \"src/input.txt\";\r\n\r\n    private void loadValues() {\r\n        File file = new File(FILE_PATH);\r\n        try (FileReader fr = new FileReader(file)) {\r\n            int content;\r\n            while ((content = fr.read()) != -1) {\r\n                codigoFuente.add((char) content);\r\n            }\r\n            codigoFuente.add('$'); //agregamos el simbolo EOF\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    //endregion\r\n\r\n    public static void InicNuevoLexema() {\r\n        lexema = null;\r\n    }\r\n\r\n    public static void agregarCharALexema(Character c) {\r\n        lexema += c;\r\n    }\r\n\r\n    public int traducirCaracter(Character c) {\r\n        //  L    \"E\" \"_\"  d  \";\" (),* +- \" \" \\n  tab  /   %  \".\" \":\"  >   <   =   &   |   $\r\n        if (Character.isAlphabetic(c)) \r\n            return 0;\r\n        if (c == 'E')\r\n            return 1;\r\n        if (c == '_')\r\n            return 2;\r\n        if (Character.isDigit(c))\r\n            return 3;\r\n        if (c == ';')\r\n            return 4;\r\n        if (c == '(' | c == ')' | c == ',' | c == '*')\r\n            return 5;\r\n        if (c == '+' | c == '-')\r\n            return 6;\r\n        if (c == ' ')\r\n            return 7;\r\n        if (c == '\\n')\r\n            return 8;\r\n        if (c == '\\t')\r\n            return 9;\r\n        if (c == '/')\r\n            return 10;\r\n        if (c == '%')\r\n            return 11;\r\n        if (c == '.')\r\n            return 12;\r\n        if (c == ':')\r\n            return 13;\r\n        if (c == '>')\r\n            return 14;\r\n        if (c == '<')\r\n            return 15;\r\n        if (c == '=')\r\n            return 16;\r\n        if (c == '&')\r\n            return 17;\r\n        if (c == '|')\r\n            return 18;\r\n        if (c == '$')\r\n            return 19;\r\n        return -1;\r\n    }\r\n\r\n    // en realidad devuelve Token+Puntero a TS\r\n\r\n    public Dupla<Integer, RegistroTS> analizar() throws Exception {\r\n\r\n        //Analizar se llama una vez por lexema. Si hay un error lexico, se lanza una excepcion que indica cual\r\n        //fue el error, para mostrarlo. El A.S. luego ejecuta el analizar de nuevo, ahora sobre la proxima letra,\r\n        //partiendo desde el estado inicial. el String lexema se vacia, y se incrementa el indiceUltimoLeido.\r\n\r\n        int tokenDetectado = 0;\r\n        int nroLinea = 1;\r\n        int estadoActual = 0;\r\n        int leidos = 0;\r\n        int estadoAnterior = 0;\r\n\r\n        int cIndex = 0;\r\n\r\n        for (Character c : codigoFuente.subList(indiceUltimoLeido, codigoFuente.size() - 1)) {\r\n\r\n            cIndex = traducirCaracter(c); // traducir c a un indice en la matriz\r\n            if (cIndex == -1){\r\n                //caracter invalido, se ignora y se pasa al siguiente\r\n            }\r\n            \r\n            estadoAnterior = estadoActual;\r\n            \r\n            estadoActual = matrizDeTransicionEstados[estadoActual][cIndex]; // obtener el estado siguiente\r\n\r\n            leidos++;\r\n\r\n            if (c.equals('\\n')) {\r\n                nroLinea++;\r\n            }\r\n\r\n            //me fui a cenar -J\r\n\r\n            if (estadoActual == -1){\r\n                //error lexico\r\n                switch(estadoAnterior){\r\n                    case 0:\r\n                        throw new Exception(\"\");\r\n                    case 1:\r\n                        throw new Exception(\"\");\r\n                    case 2:\r\n                        throw new Exception(\"\");\r\n                    case 3:\r\n                        throw new Exception(\"\");\r\n                    case 4:\r\n                        throw new Exception(\"\");\r\n                    case 5:\r\n                        throw new Exception(\"\");\r\n                    case 6:\r\n                        throw new Exception(\"\");\r\n                    case 7:\r\n                        throw new Exception(\"\");\r\n                    case 8:\r\n                        throw new Exception(\"\");\r\n                    case 9:\r\n                        throw new Exception(\"\");\r\n                    case 10:\r\n                        throw new Exception(\"\");\r\n                    case 11:\r\n                        throw new Exception(\"\");\r\n                    case 12:\r\n                        throw new Exception(\"\");\r\n                    case 13:\r\n                        throw new Exception(\"\");\r\n                    case 14:\r\n                        throw new Exception(\"\");\r\n                    case 15:\r\n                        throw new Exception(\"\");\r\n                    default:\r\n                        throw new Exception(\"\");\r\n                }\r\n            }\r\n            \r\n            IAccionSemantica AS = matrizDeTransicionAS[estadoAnterior][cIndex];\r\n\r\n            if (AS == null) //si no tenemos que hacer una AS, avanzamos\r\n                continue;\r\n\r\n            if (estadoActual == estadoFinal) {\r\n                // si el proxEstado es el final sabemos que la AS devuelve lo que deba\r\n                // devolverle al Sintactico\r\n                // dependiendo la AS, puede que devuelva el ultimo caracter a la entrada\r\n                // (leidos--) o no.\r\n\r\n                if (AS.devuelveUltimoALaEntrada()) {\r\n                    leidos--;\r\n                }\r\n\r\n                indiceUltimoLeido += leidos;\r\n\r\n                // return ejecutar AS[estadoActual][cTraducida](estadoAnterior, c);\r\n                // esta AS devuelve el token y el puntero a la TS si es necesario\r\n\r\n                return AS.ejecutar(estadoAnterior, c);\r\n\r\n            } else {\r\n\r\n                // la AS no va a devolver nada\r\n                // ejecutar AccionSemantica[estadoActual][cTraducida](estadoAnterior, c);\r\n                AS.ejecutar(estadoAnterior, c);\r\n            }\r\n        }\r\n\r\n        return null;\r\n        // TODO : Hacer Handling de lexema sin final\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Dev/Lexico/AnalizadorLexico.java b/src/Dev/Lexico/AnalizadorLexico.java
--- a/src/Dev/Lexico/AnalizadorLexico.java	(revision f5050742fd0debe37e51b23cabc703a07f890d69)
+++ b/src/Dev/Lexico/AnalizadorLexico.java	(date 1632844648329)
@@ -211,7 +211,6 @@
                 nroLinea++;
             }
 
-            //me fui a cenar -J
 
             if (estadoActual == -1){
                 //error lexico
Index: src/TP2/gramatica.y
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n{%\r\n\r\n%}\r\n\r\n%token\r\n\r\n%start\r\n\r\n// TODO : Revisar tema (;)\r\n// TODO : Se debe incorporar al Análisis Léxico el reconocimiento de la palabra reservada POST, y el símbolo \":\".}\r\n// TODO : Preguntar tema BREAK\r\n\r\n%%\r\n\r\nprograma\t: bloque_sentencias\r\n\t\t\t;\r\n\t\t\t\r\ntipo_id\t: UINT {helper.setUltimoTipoLeido(\"UINT\");}\r\n\t\t| DOUBLE {helper.setUltimoTipoLeido(\"DOUBLE\");}\r\n\t\t;\r\n\r\nbloque_sentencias\t: sentencia_decl ',' sentencia_de_ejecucion ';'\r\n\t\t\t\t\t| sentencia_de_ejecucion ';'\r\n\t\t\t\t\t;\r\n\r\nsentencia_de_ejecucion  :  BEGIN sentencia_ejec RETURN retorno END\r\n                        |  BEGIN sentencia_ejec RETURN retorno post_condicion END\r\n\r\npost_condicion          : POST ':' condicion ',' cadena\r\n\r\nretorno             : expresion ';'\r\n\r\nsentencia_decl\t: tipo_id nombre_func params_func cuerpo_func {helper.eliminarUltimoAmbito();}\r\n\t\t\t\t| tipo_id lista_variables\r\n\t\t\t\t;\r\n\r\nlista_variables\t: ID {helper.declaracionVar($1.sval);}\r\n\t\t\t\t| ID ',' lista_variables {helper.declaracionVar($1.sval);}\r\n\t\t\t\t;\r\n\r\n\r\nnombre_func\t: FUNC ID {helper.lecturaIdProc($2.sval);}\r\n\t\t\t| FUNC {yyerror(\"Falta el identificador del procedimiento.\");}\r\n\t\t\t;\r\n\t\t\t\r\nparams_func\t: '(' param ')'\r\n\t\t\t| '(' ')'\r\n\t\t\t| '(' param {yyerror(\"Falta el parentesis de cierre para los parametros.\");}\r\n\t\t\t| '(' {yyerror(\"Falta el parentesis de cierre para los parametros.\");}\r\n\t\t\t;\r\n\r\nparam : tipo_id ID {helper.lecturaParamFormal($2.sval, Celda.USO_PARAM_CV);}\r\n\t\t    | tipo_id {yyerror(\"Falta el identificador de un parametro.\");}\r\n\t\t    ;\r\n\r\nseparador_variables\t:       {yyerror(\"Falta una ',' para separar dos parametros.\");}\r\n\t\t\t\t\t| ','\r\n\t\t\t\t\t;\r\n\t\t\r\ncuerpo_func\t: bloque_sentencias\r\n\t\t\t| '{' '}' {yyerror(\"Cuerpo del procedimiento vacio.\");}\r\n\t\t\t;\r\n\r\nsentencia_ejec\t: miembro_sentencia_ejec sentencia_ejec\r\n\t\t\t\t| miembro_sentencia_ejec             \r\n\t\t\t\t;\r\n\r\nmiembro_sentencia_ejec : invocacion\r\n                       | asignacion\r\n                       | loop\r\n                       | if\r\n                       |    \r\n\r\ninvocacion\t: ID '(' ')' {helper.invocacionProc($1.sval);}\r\n\t\t\t| ID '(' lista_params_inv ')' {helper.invocacionProc($1.sval);}\r\n\t\t\t;\r\n\r\nparam_inv   : ID {helper.guardaParamsInvoc($1.sval);}\r\n            | CTE_UINT {helper.guardaParamsInvoc($1.sval);}\r\n            | CTE_DOUBLE {helper.guardaParamsInvoc($1.sval);}\r\n            ;\r\n\t\t\t\r\nlista_params_inv\t: param_inv\r\n\t\t\t\t\t| param_inv separador_variables param_inv\r\n\t\t\t\t\t| param_inv separador_variables param_inv separador_variables param_inv\r\n\t\t\t\t\t| param_inv separador_variables param_inv separador_variables param_inv separador_variables lista_params_inv\r\n                                                    {yyerror(\"Un procedimiento no puede tener mas de 3 parametros.\");}\r\n                    ;\r\n\r\nasignacion\t: ID '=' expresion {helper.lecturaDestAsign($1.sval);}\r\n            | ID '=' error {\r\n                            helper.lecturaDestAsign($1.sval);\r\n                            yyerror(\"El lado derecho de la asignacio no es valido.\");\r\n                            }\r\n            | ID {\r\n                    helper.lecturaDestAsign($1.sval);\r\n                    yyerror(\"Un identificador en solitario no es una sentencia valida.\");\r\n                    }\r\n            | error '=' expresion {yyerror(\"El lado izquierdo de la asignacion no es valido\");}\r\n\r\n            ;\r\n\t\t\t\r\nexpresion\t: expresion '+' termino {helper.agregarPasosRepr(\"+\");}\r\n\t\t\t| expresion '-' termino {helper.agregarPasosRepr(\"-\");}\r\n\t        | termino\r\n\t\t\t;\r\n    \t\t\r\ntermino\t: termino '*' factor {helper.agregarPasosRepr(\"*\");}\r\n\t\t| termino '/' factor {helper.agregarPasosRepr(\"/\");}\r\n\t\t| factor\r\n     \t;\t\r\n\t\t\r\nfactor \t: ID {helper.lecturaFactor($1.sval);}\r\n\t\t| CTE_UINT {helper.agregarPasosRepr($1.sval);helper.setTipoUltimoFactor(\"UINT\");}\r\n\t\t| CTE_DOUBLE {helper.agregarPasosRepr($1.sval);helper.setTipoUltimoFactor(\"DOUBLE\");}\r\n\t\t| '-' factor    {helper.cambioSignoFactor(yylval.sval);}\r\n\t\t| invocacion    {helper.cambioSignoFactor(yylval.sval);}\r\n\t\t;\r\n\r\nprint\t: PRINT '(' '%' CADENA '%' ')'\r\n        | PRINT '(' error ')'\r\n\t\t;\r\n\t\t\r\nbloque_estruct_ctrl\t: sentencia_ejec fin_sentencia\r\n\t\t\t\t\t| '{' bloque_sentencias_ejec '}'\r\n\t\t\t\t\t| '{' '}' {yyerror(\"Bloque de sentencias vacio.\");}\r\n\t\t\t\t\t| sentencia_decl fin_sentencia {yyerror(\"No se permiten sentencias declarativas dentro de un bloque de estructura de control.\");}\r\n\t\t\t\t\t;\r\n\r\nbloque_sentencias_ejec\t: sentencia_ejec \r\n\t\t\t\t\t\t| sentencia_de_ejecucion \r\n\t\t\t\t\t\t;\r\n\r\nloop\t: encab_loop cuerpo_loop cuerpo_until\r\n\t\t;\r\n\r\nencab_loop  : REPEAT {helper.puntoControlLoop();}\r\n            ;\r\n\t\t\r\ncuerpo_loop\t: bloque_estruct_ctrl\r\n            | {yyerror(\"Falta el bloque de sentencias ejecutables del LOOP.\");}\r\n\t\t\t;\r\n\t\t\r\ncuerpo_until\t: UNTIL condicion {helper.puntoControlUntil();}\r\n                | UNTIL {yyerror(\"Falta la condicion de corte del LOOP.\");}\r\n                ;\r\n\r\ncondicion\t: '(' expresion comparador expresion ')' {helper.agregarPasosRepr($3.sval);}\r\n            | '(' expresion comparador expresion {yyerror(\"Falta parentesis de cierre de la condicion.\");}\r\n            | '(' comparador expresion ')' {yyerror(\"Falta expresion en el lado izquierdo de la condicion.\");}\r\n            | '(' expresion comparador ')' {yyerror(\"Falta expresion en el lado derecho de la condicion.\");}\r\n            | '(' expresion operador_logico expresion ')'\r\n            | '(' error ')' {yyerror(\"Error en la condicion.\");}  // verificar el error\r\n\t\t\t;\r\n\t\t\t\r\ncomparador \t: COMP_MAYOR_IGUAL\r\n\t\t\t| COMP_MENOR_IGUAL\r\n\t\t\t| '<'\r\n\t\t\t| '>'\r\n\t\t\t| COMP_IGUAL\r\n\t\t\t| COMP_DISTINTO\r\n\t\t\t;\r\n\r\noperador_logico : &&\r\n                | ||\r\n \r\nif\t: encabezado_if rama_then rama_else ENDIF ';'\r\n\t| encabezado_if rama_then_prima ENDIF ';'\r\n\t;\r\n\r\nencabezado_if\t: IF condicion {helper.puntoControlThen();}\r\n                | IF {yyerror(\"Falta la condicion del IF.\");}\r\n\t\t\t\t;\r\n\t\t\t\t\r\nrama_then\t: THEN bloque_estruct_ctrl {helper.puntoControlElse();}\r\n            | THEN {yyerror(\"Falta el bloque de sentencias ejecutables de la rama THEN.\");}\r\n\t\t\t;\r\n\r\nrama_then_prima : THEN bloque_estruct_ctrl {helper.puntoControlFinCondicional();}\r\n                | THEN {yyerror(\"Falta el bloque de sentencias ejecutables de la rama THEN.\");}\r\n                ;\r\n\t\t\t\r\nrama_else\t: ELSE bloque_estruct_ctrl {helper.puntoControlFinCondicional();}\r\n            | ELSE {yyerror(\"Falta el bloque de sentencias ejecutables de la rama ELSE.\");}\r\n\t\t\t;\r\n\r\n%%\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/TP2/gramatica.y b/src/TP2/gramatica.y
--- a/src/TP2/gramatica.y	(revision f5050742fd0debe37e51b23cabc703a07f890d69)
+++ b/src/TP2/gramatica.y	(date 1632857715411)
@@ -35,11 +35,10 @@
 				| tipo_id lista_variables
 				;
 
-lista_variables	: ID {helper.declaracionVar($1.sval);}
-				| ID ',' lista_variables {helper.declaracionVar($1.sval);}
-				;
+lista_variables					: ID {helper.declaracionVar($1.sval);}
+						| ID ',' lista_variables {helper.declaracionVar($1.sval);}
+						;
 
-
 nombre_func	: FUNC ID {helper.lecturaIdProc($2.sval);}
 			| FUNC {yyerror("Falta el identificador del procedimiento.");}
 			;
@@ -177,13 +176,13 @@
             | THEN {yyerror("Falta el bloque de sentencias ejecutables de la rama THEN.");}
 			;
 
-rama_then_prima : THEN bloque_estruct_ctrl {helper.puntoControlFinCondicional();}
-                | THEN {yyerror("Falta el bloque de sentencias ejecutables de la rama THEN.");}
-                ;
-			
-rama_else	: ELSE bloque_estruct_ctrl {helper.puntoControlFinCondicional();}
-            | ELSE {yyerror("Falta el bloque de sentencias ejecutables de la rama ELSE.");}
-			;
+rama_then_prima 			: THEN bloque_estruct_ctrl {helper.puntoControlFinCondicional();}
+							| THEN {yyerror("Falta el bloque de sentencias ejecutables de la rama THEN.");}
+							;
+
+rama_else					: ELSE bloque_estruct_ctrl {helper.puntoControlFinCondicional();}
+					    	| ELSE {yyerror("Falta el bloque de sentencias ejecutables de la rama ELSE.");}
+							;
 
 %%
 
Index: out/production/Compiladores/input.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>int a = 6\r\nif ( a == 6) {\r\n    return true\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/out/production/Compiladores/input.txt b/out/production/Compiladores/input.txt
--- a/out/production/Compiladores/input.txt	(revision f5050742fd0debe37e51b23cabc703a07f890d69)
+++ b/out/production/Compiladores/input.txt	(date 1632844517951)
@@ -1,4 +1,4 @@
-int a = 6
+int a := 6
 if ( a == 6) {
     return true
 }
\ No newline at end of file
