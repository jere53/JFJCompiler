Index: src/Dev/Lexico/AnalizadorLexico.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package Dev.Lexico;\r\n\r\nimport Dev.RegistroTS;\r\nimport Dev.Lexico.AccionesSemanticas.*;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.io.File;\r\nimport java.io.IOException;\r\nimport java.io.FileReader;\r\nimport java.util.ArrayList;\r\n\r\npublic class AnalizadorLexico {\r\n\r\n    public static Map<String, Integer> numeroToken = new HashMap<>();\r\n\r\n    private static AnalizadorLexico instance;\r\n\r\n    public static AnalizadorLexico Instance() {\r\n        if (instance == null)\r\n            instance = new AnalizadorLexico();\r\n        return instance;\r\n    }\r\n\r\n    private AnalizadorLexico() {\r\n        loadValues();\r\n        numeroToken.put(\"Identificador\", 300); // el numero de token que corresponde a un ID es 300\r\n        numeroToken.put(\"/\", 400);\r\n        numeroToken.putAll(Map.of(\":=\", 501, \">=\", 502, \">\", 503, \"<=\", 504, \"<>\", 505, \"<\", 506, \"==\", 507, \"&&\", 508, \"||\", 509));\r\n        numeroToken.putAll(Map.of(\";\", 510, \"+\", 511, \"-\", 512, \"*\", 513, \"(\", 514, \")\", 515, \",\", 516));\r\n        numeroToken.putAll(Map.of(\"ERR_CTE_FUERA_RANGO\", 600, \"CTE_UINT\", 601, \"ERR_FORMATO_CTE\", 602, \"CTE_DOUBLE\", 603));\r\n        numeroToken.put(\"CADENA\", 700);\r\n    }\r\n\r\n    private static final int estadoFinal = 16;\r\n\r\n    //region Matrices\r\n    private static final int[][] matrizDeTransicionEstados = {\r\n        {1,1,1,2,estadoFinal,estadoFinal,estadoFinal,0,0,0,6,15,3,9,10,11,12,13,14,estadoFinal}, //0\r\n        {1,estadoFinal,1,1,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {estadoFinal,estadoFinal,estadoFinal,2,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,3,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {estadoFinal,4,estadoFinal,3,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {estadoFinal,estadoFinal,estadoFinal,4,estadoFinal,estadoFinal,5,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {estadoFinal,estadoFinal,estadoFinal,5,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,7,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {7,7,7,7,7,7,7,7,7,7,8,7,7,7,7,7,7,7,7,-1},\r\n        {7,7,7,7,7,7,7,7,7,7,0,7,7,7,7,7,7,7,7,-1},\r\n        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,estadoFinal,-1,-1,-1},\r\n        {estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal,estadoFinal},\r\n        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,estadoFinal,-1,-1,-1},\r\n        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,estadoFinal,-1,-1},\r\n        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,estadoFinal,-1},\r\n        {15,15,15,15,15,15,15,15,-1,15,15,estadoFinal,15,15,15,15,15,15,15,-1}\r\n    };\r\n    \r\n    static IAccionSemantica AS1 = new AS1();\r\n    static IAccionSemantica AS2 = new AS2();\r\n    static IAccionSemantica AS3 = new AS3();\r\n    static IAccionSemantica AS4 = new AS4();\r\n    static IAccionSemantica AS5 = new AS5();\r\n    static IAccionSemantica AS6 = new AS6();\r\n    static IAccionSemantica AS7 = new AS7();\r\n    \r\n    private static final IAccionSemantica[][] matrizDeTransicionAS = {\r\n        {AS2, AS2, AS2, AS2, AS1, AS1, AS1, null, null, null, null, AS2, AS2, null, null, null, null, null, null, null}, //0\r\n        {AS3, AS3, AS3, AS3, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4, AS4}, //1\r\n        {AS5, AS5, AS5, AS3, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS3, AS5, AS5, AS5, AS5, AS5, AS5, AS5}, //2\r\n        {AS5, AS3, AS5, AS3, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5},//3\r\n        {AS5, AS5, AS5, AS3, AS5, AS5, AS3, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5},//4\r\n        {AS5, AS5, AS5, AS3, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5, AS5},//5\r\n        {AS6, AS6, AS6, AS6, AS6, AS6, AS6, AS6, AS6, AS6, null, AS6, AS6, AS6, AS6, AS6, AS6, AS6, AS6, AS6},//6\r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},//7\r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null},//8\r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, AS1, null, null, null},//9\r\n        {AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1}, //10\r\n        {AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1, AS1}, //11 \r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, AS1, null, null, null},//12\r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, AS1, null, null},//13\r\n        {null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, AS1, null},//14\r\n        {AS3, AS3, AS3, AS3, AS3, AS3, AS3, AS3, null, AS3, AS3, AS7, AS3, AS3, AS3, AS3, AS3, AS3, AS3, null} //15\r\n\r\n        \r\n/*\r\n           L    \"E\" \"_\"  d  \";\" (),* +- \" \" \\n  tab  /   %  \".\" \":\"  >   <   =   &   |   $\r\n0         AS2\tAS2\tAS2\tAS2\tAS1\tAS1\tAS1\t\t\t\t\tAS2\tAS2\t\t\t\t\t\t\t\r\n1         AS3\tAS3\tAS3\tAS3\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\tAS4\r\n2                       AS3\tAS5\t\t\tAS5\tAS5\t\t\t\tAS3\t\t\t\t\t\t\t\r\n3               AS3\t    AS3\tAS5\t\t\tAS5\tAS5\t\t\t\t\t\t\t\t\t\t\t\r\n4                       AS3\tAS5\t\tAS3\tAS5\tAS5\t\t\t\t\t\t\t\t\t\t\t\r\n5                       AS3\tAS5\t\t\tAS5\tAS5\t\t\t\t\t\t\t\t\t\t\t\r\n6         AS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\t\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\tAS6\r\n7                                                                                     \r\n8                                                                                     \r\n9                                                                           AS1\t\t\t\r\n10        AS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\r\n11        AS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\tAS1\r\n12                                                                          AS1\t\t\t\r\n13                                                                              AS1\t\t\r\n14                                                                                  AS1\t\r\n15        AS3\tAS3\tAS3\tAS3\tAS3\tAS3\tAS3\tAS3\t\tAS3\tAS3\tAS7\tAS3\tAS3\tAS3\tAS3\tAS3\tAS3\tAS3\t\r\n*/\r\n    };\r\n\r\n    //endregion\r\n\r\n    private static List<Character> codigoFuente = new ArrayList<>();\r\n\r\n    private static int indiceUltimoLeido = 0;\r\n\r\n    public static String lexema;\r\n\r\n    //region FileRead\r\n\r\n    final static String FILE_PATH = \"src/input.txt\";\r\n\r\n    private void loadValues() {\r\n        File file = new File(FILE_PATH);\r\n        try (FileReader fr = new FileReader(file)) {\r\n            int content;\r\n            while ((content = fr.read()) != -1) {\r\n                if ((char) content == '\\r') continue;\r\n                codigoFuente.add((char) content);\r\n            }\r\n            codigoFuente.add('$'); //agregamos el simbolo EOF\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    //endregion\r\n\r\n    public static void InicNuevoLexema() {\r\n        lexema = \"\";\r\n    }\r\n\r\n    public static void agregarCharALexema(Character c) {\r\n        lexema += c;\r\n    }\r\n\r\n    public int traducirCaracter(Character c) {\r\n        //  L    \"E\" \"_\"  d  \";\" (),* +- \" \" \\n  tab  /   %  \".\" \":\"  >   <   =   &   |   $\r\n        if (Character.isAlphabetic(c)) \r\n            return 0;\r\n        if (c == 'E')\r\n            return 1;\r\n        if (c == '_')\r\n            return 2;\r\n        if (Character.isDigit(c))\r\n            return 3;\r\n        if (c == ';')\r\n            return 4;\r\n        if (c == '(' | c == ')' | c == ',' | c == '*')\r\n            return 5;\r\n        if (c == '+' | c == '-')\r\n            return 6;\r\n        if (c == ' ')\r\n            return 7;\r\n        if (c == '\\n')\r\n            return 8;\r\n        if (c == '\\t')\r\n            return 9;\r\n        if (c == '/')\r\n            return 10;\r\n        if (c == '%')\r\n            return 11;\r\n        if (c == '.')\r\n            return 12;\r\n        if (c == ':')\r\n            return 13;\r\n        if (c == '>')\r\n            return 14;\r\n        if (c == '<')\r\n            return 15;\r\n        if (c == '=')\r\n            return 16;\r\n        if (c == '&')\r\n            return 17;\r\n        if (c == '|')\r\n            return 18;\r\n        if (c == '$')\r\n            return 19;\r\n        return -1;\r\n    }\r\n\r\n    // en realidad devuelve Token+Puntero a TS\r\n\r\n    public Dupla<Integer, RegistroTS> analizar() throws Exception {\r\n\r\n        //Analizar se llama una vez por lexema. Si hay un error lexico, se lanza una excepcion que indica cual\r\n        //fue el error, para mostrarlo. El A.S. luego ejecuta el analizar de nuevo, ahora sobre la proxima letra,\r\n        //partiendo desde el estado inicial. el String lexema se vacia, y se incrementa el indiceUltimoLeido.\r\n\r\n        int tokenDetectado = 0;\r\n        int nroLinea = 1;\r\n        int estadoActual = 0;\r\n        int leidos = 0;\r\n        int estadoAnterior;\r\n\r\n        int cIndex;\r\n\r\n        for (Character c : codigoFuente.subList(indiceUltimoLeido, codigoFuente.size() - 1)) {\r\n\r\n            cIndex = traducirCaracter(c); // traducir c a un indice en la matriz\r\n            if (cIndex == -1){\r\n                //caracter invalido, se ignora y se pasa al siguiente\r\n                System.out.println(\"caracter Invalido\");\r\n                continue;\r\n            }\r\n            \r\n            estadoAnterior = estadoActual;\r\n            \r\n            estadoActual = matrizDeTransicionEstados[estadoAnterior][cIndex]; // obtener el estado siguiente\r\n\r\n            leidos++;\r\n\r\n            if (c.equals('\\n')) {\r\n                nroLinea++;\r\n            }\r\n\r\n\r\n            if (estadoActual == -1){\r\n                System.out.println(\"Estado Anterior: \" + estadoAnterior + \" caracter: \" + c);\r\n                //error lexico\r\n                switch(estadoAnterior){\r\n                    case 0:\r\n                        throw new Exception(\"\");\r\n                    case 1:\r\n                        throw new Exception(\"\");\r\n                    case 2:\r\n                        throw new Exception(\"\");\r\n                    case 3:\r\n                        throw new Exception(\"\");\r\n                    case 4:\r\n                        throw new Exception(\"\");\r\n                    case 5:\r\n                        throw new Exception(\"\");\r\n                    case 6:\r\n                        throw new Exception(\"\");\r\n                    case 7:\r\n                        throw new Exception(\"\");\r\n                    case 8:\r\n                        throw new Exception(\"\");\r\n                    case 9:\r\n                        throw new Exception(\"\");\r\n                    case 10:\r\n                        throw new Exception(\"\");\r\n                    case 11:\r\n                        throw new Exception(\"\");\r\n                    case 12:\r\n                        throw new Exception(\"\");\r\n                    case 13:\r\n                        throw new Exception(\"\");\r\n                    case 14:\r\n                        throw new Exception(\"\");\r\n                    case 15:\r\n                        throw new Exception(\"\");\r\n                    default:\r\n                        throw new Exception(\"\");\r\n                }\r\n            }\r\n            \r\n            IAccionSemantica AS = matrizDeTransicionAS[estadoAnterior][cIndex];\r\n\r\n            if (AS == null) //si no tenemos que hacer una AS, avanzamos\r\n                continue;\r\n\r\n            if (estadoActual == estadoFinal) {\r\n                // si el proxEstado es el final sabemos que la AS devuelve lo que deba\r\n                // devolverle al Sintactico\r\n                // dependiendo la AS, puede que devuelva el ultimo caracter a la entrada\r\n                // (leidos--) o no.\r\n\r\n                if (AS.devuelveUltimoALaEntrada()) {\r\n                    leidos--;\r\n                }\r\n\r\n                indiceUltimoLeido += leidos;\r\n\r\n                // return ejecutar AS[estadoActual][cTraducida](estadoAnterior, c);\r\n                // esta AS devuelve el token y el puntero a la TS si es necesario\r\n\r\n                return AS.ejecutar(estadoAnterior, c);\r\n\r\n            } else {\r\n\r\n                // la AS no va a devolver nada\r\n                // ejecutar AccionSemantica[estadoActual][cTraducida](estadoAnterior, c);\r\n                AS.ejecutar(estadoAnterior, c);\r\n            }\r\n        }\r\n\r\n        //aca llegamos al EOF\r\n        return new Dupla<>(69, null);\r\n        // TODO : Hacer Handling de lexema sin final\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Dev/Lexico/AnalizadorLexico.java b/src/Dev/Lexico/AnalizadorLexico.java
--- a/src/Dev/Lexico/AnalizadorLexico.java	(revision eede122de404c8720fda257c84dcec2d5eed7790)
+++ b/src/Dev/Lexico/AnalizadorLexico.java	(date 1632953840981)
@@ -192,7 +192,6 @@
         //fue el error, para mostrarlo. El A.S. luego ejecuta el analizar de nuevo, ahora sobre la proxima letra,
         //partiendo desde el estado inicial. el String lexema se vacia, y se incrementa el indiceUltimoLeido.
 
-        int tokenDetectado = 0;
         int nroLinea = 1;
         int estadoActual = 0;
         int leidos = 0;
Index: src/TP2/Main.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package TP2;\r\n\r\nimport Dev.Lexico.AnalizadorLexico;\r\nimport Dev.Lexico.Dupla;\r\nimport Dev.Lexico.TablaSimbolos;\r\nimport Dev.RegistroTS;\r\n\r\npublic class Main {\r\n\r\n    public static void main(String[] args) {\r\n        TablaSimbolos.CargarTablaSimbolos();\r\n\r\n        Dupla<Integer, RegistroTS> token;\r\n        int attempts = 0;\r\n        do {\r\n            try {\r\n                token = AnalizadorLexico.Instance().analizar();\r\n                if (token.second != null)\r\n                    System.out.println(token.first + \" : \" + token.second.getLexema());\r\n                else\r\n                    System.out.println(token.first);\r\n            } catch (Exception e) {\r\n                System.out.println(\"F\");\r\n                break;\r\n            }\r\n        } while (token.first != 69);\r\n    }\r\n\r\n    private static int yylex(){\r\n        TablaSimbolos.CargarTablaSimbolos(); //invocamos el constructor para que cargue los primeros valores a los mapas\r\n        // Variable para saber si debemos seguir pidiendo tokens al analizador Lexico\r\n        Dupla<Integer, RegistroTS> token; // ELEGIR MEJOR NOMBRE\r\n        // Pedimos un token al analizador lexico el cual es entregado en forma de dupla\r\n        do{\r\n            try {\r\n                token = AnalizadorLexico.Instance().analizar();\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n                token = null;\r\n            }\r\n        } while (token == null);\r\n        return token.first; // Retorno el numero de token\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/TP2/Main.java b/src/TP2/Main.java
--- a/src/TP2/Main.java	(revision eede122de404c8720fda257c84dcec2d5eed7790)
+++ b/src/TP2/Main.java	(date 1632953826615)
@@ -42,3 +42,4 @@
         return token.first; // Retorno el numero de token
     }
 }
+
